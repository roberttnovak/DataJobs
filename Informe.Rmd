---
title: "Informe"
author: "Geovanny Risco y Robert Novak"
date: "28/12/2021"
output: html_document
---

<!-- Para después de ejecutar el knitr ponerlo en la consola para cargar las variables rmarkdown::render("Informe.Rmd") -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Importación de librerías 

```{r}
library(tidyverse)
#library(kableExtra)
library(pander) #Para mostrar los vectores más estéticamente
library(DT)
library(readr)
```

# Importación del dataset

```{r, cache=T}
raw_data <- read_csv("Data/Raw/uncleaned_data.csv")
```

```{r}
# raw_data %>% DT::datatable(
#   extensions = 'FixedColumns',
#   options = list(
#     dom = 't',
#     scrollX = TRUE,
#     scrollCollapse = TRUE)
#   )
```

# Exploración del dominio de las variables

## Nombre de todas las variables

```{r}
cols_raw_data <- names(raw_data)
cols_raw_data
```

## Selección de las variables de interés para el estudio del dominio


```{r}
cols_no_interest <- c("index","Job Description") #Eliminamos Job Description de momento por tener demasiada información
cols_raw_data_filtered <- cols_raw_data[-which(cols_raw_data %in% cols_no_interest)]
```

## Visualización en forma de lista del dominio de cada variable

```{r}
cols_raw_data_filtered %>% 
  map(function(x) unique(raw_data[[x]])) %>% 
  setNames(cols_raw_data_filtered) -> list_domain
list_domain
```


# Limpieza de datos

## Puntos a tener en cuenta para la limpieza de datos 

A raíz del estudio hecho en el apartado anterior, hay que tener en cuenta los siguientes puntos para la limpieza de datos:

1. Se utiliza el `-1` para indicar valores faltantes. Adicionalmente, existen columnas que tienen un valor faltante que se representa de forma distinta a `-1` por la forma en la que se han extraído los datos. En la limpieza tendremos que tener en cuenta también esos casos y representar a todos los valores faltantes de forma homogénea mediante `NA`

1. La columna `Job title` tiene una gran diversidad de trabajos con una mínima variación que sería interesante tratarlos como un mismo trabajo. Para ello, habrá que definir un subconjunto de trabajos a partir del cuál tratar como iguales las variantes. Ese subconjunto será los que consideramos principales : \{ data scientist, data engineer, data analyst, machine learning, machine learning expert \}. Así, por ejemplo, un trabajo de e-commerce data analyst o uno de RFP data analyst será tratado bajo la categoría de data analyst

1. La variable `Company name` tiene la información del rating. Habrá que eliminar esa redundancia

1. Es interesante añadir una nueva variable binaria a partir de `Location` y `Headquarters` para ver aquellas ofertas de trabajo en la que la sede central de la empresa está en el mismo sitio que la oferta 

1. Algunas variables como `Salary Estimate`, `Size` y `Revenue` contienen información que pueden ser aprovechadas mejor separándolas en más columnas a partir de las cuáles sacar más información 

## Tratamiento de la variable `Job Titles`
```{r}
clean_data <- raw_data

# Asignamos el valor NA en todas las celdas de la tabla donde aparece un -1 o un Unknown
# Esto lo podemos hacer porque entre las variables numéricas que tenemos no hay ninguna en la que en su dominio tenga valores negativos
clean_data[clean_data==-1 | clean_data=="Unknown" | clean_data=="Unknown / Non-Applicable"] <- NA

data_jobs_titles <- "data scientist|data engineer|data analyst|machine learning" 

# Tratamos el nombre de los trabajos para considerar idénticos aquellos que tienen mínimas variaciones
clean_data <- clean_data %>% 
  mutate(`Job Title`= tolower(`Job Title`) %>% 
           str_extract(data_jobs_titles)
         )
```

Ahora comprobemos qué tipo de trabajos se han quedado fuera:

```{r}
out_jobs_index <- clean_data[is.na(clean_data$`Job Title`),] %>% 
  select(index) %>% 
  as_vector() %>% 
  unname() 

out_jobs <- raw_data %>% 
  filter(`index` %in% out_jobs_index) %>% 
  select(`Job Title`) %>% 
  distinct() %>% 
  datatable()
```

Consideramos que los trabajos que se quedan fuera son demasiado específicos para el análisis que queremos hacer posteriormente. Además, el número de observaciones que perderíamos si no consideraramos el estudio posterior para ninguna de estas profesiones es de `r length(out_jobs_index)` lo que consideramos una cifra asumible. 

```{r}
clean_data <- clean_data[!is.na(clean_data$`Job Title`),]
```

## Tratamiento de la variable `Salary Estimate`

Esta variable es interesante separarla en dos: una para el rango mínimo y otra para el rango máximo. Adicionalmente, es interesante crear una nueva a partir de estas dos que sea el rango medio. 

Para ello, como hay muchas observaciones diferentes de rangos distintos nos aseguramos de forma automatizada que todos los rangos están en miles:


```{r}

all_k <- raw_data %>% 
  select(`Salary Estimate`) %>% 
  distinct() %>% 
  map(function(x) grepl(".*K.*K",x)) %>% 
  as_vector() %>% 
  all()

if(all_k){
  cat("Todas las observaciones están en miles, no hay que tener ningún cuidado especial")
}else{
  cat("¡Cuidado! Existen algunas observaciones que no están en miles, hay que tratar esas observaciones")
}
```

```{r}
clean_data <- clean_data %>% 
  separate(`Salary Estimate`,sep="-", into=c("Salary Estimate Inf","Salary Estimate Sup")) %>%
  mutate(
    `Salary Estimate Inf` = gsub("K|\\$","",`Salary Estimate Inf`),
    `Salary Estimate Sup` = gsub("K|\\$","",`Salary Estimate Sup`) 
  ) %>% 
  #Lo separamos de nuevo para evitar poner todas las variaciones posibles Glassdoor est., Employer Est. etc
  separate(`Salary Estimate Sup`, sep="\\(", into=c("Salary Estimate Sup", "drop")) %>% 
  select(-drop ) %>% 
  mutate(
    `Salary Estimate Inf` = as.double(`Salary Estimate Inf`),
    `Salary Estimate Sup` = as.double(`Salary Estimate Sup`),
    `Salary Estimate Med` = (`Salary Estimate Inf` + `Salary Estimate Sup`)/2
  )
```

## Tratamiento de la variable `Company Name`

```{r}
clean_data <- clean_data %>% 
  mutate(`Company Name`=str_remove_all(`Company Name`,"\n.*"))
```

## Tratamiento de la variable `Headquarters` y `Location`

```{r}
clean_data <-  clean_data %>% 
  mutate(`Same Location Headquarter`= Location==Headquarters)
```

## Tratamiento de la variable `Size`

Esta variable será tratada de forma análoga a `Salary Estimate`.

```{r}
clean_data <- clean_data %>% 
  mutate(Size=gsub("employees|\\+","",Size)) %>% 
  separate(Size,sep="to", into=c("Size Inf","Size Sup")) %>% 
  mutate(`Size Inf`=as.integer(`Size Inf`),
         `Size Sup`=as.integer(`Size Sup`),
         `Size Med`= ((`Size Inf` + `Size Sup`) / 2) %>%
           # Para aquellas observaciones que no tienen rango superior asumimos el 
           # ínfimo como medio para no dejarlo com faltante
           ifelse(is.na(.),`Size Inf`,.) 
         ) 
```

## Tratamiento de la variable `Revenue`

Para esta variable, aparte de sacar los valores extremos, sería adecuada tratarla como una variable ordinal

```{r}
nice_revenue_format <- function(x) {
  print(x)
  if(is.na(x)){
    return(NA_character_)
  }else if(x=="$100 to $500 million (USD)"){
    return("100000000-500000000")
  }else if("$2 to $5 billion (USD)"){ 
    return("2000000000-5000000000")
  }else if("$5 to $10 billion (USD)"){ 
    return("5000000000-10000000000")
  }else if("$25 to $50 million (USD)"){ 
    return("25000000-50000000")
  }else if("$1 to $5 million (USD)"){ 
    return("1000000-5000000")
  }else if("Less than $1 million (USD)"){ 
    return("0-1000000")
  }else if("$1 to $2 billion (USD)"){ 
    return("1000000000-2000000000")
  }else if("$10+ billion (USD)"){ 
    return("10000000000-")
  }else if("$500 million to $1 billion (USD)"){ 
    return("500000000-1000000000")
  }else if("$10 to $25 million (USD)"){ 
    return("10000000-25000000")
  }else if("$50 to $100 million (USD)"){ 
    return("50000000-100000000")
  }else if("$5 to $10 million (USD)"){ 
    return("5000000-10000000")
  }else{
    return(NA)
  }
}

nice_revenue_format_vec <- function(vector){
  return(vector %>% 
    map_chr(function(x) nice_revenue_format(x)))
}

revenue_order <- function(x) {
  if(x=="$100 to $500 million (USD)"){
    return(7)
  }else if("$2 to $5 billion (USD)"){ 
    return(10)
  }else if("$5 to $10 billion (USD)"){ 
    return(11)
  }else if("$25 to $50 million (USD)"){ 
    return(5)
  }else if("$1 to $5 million (USD)"){ 
    return(2)
  }else if("Less than $1 million (USD)"){ 
    return(1)
  }else if("$1 to $2 billion (USD)"){ 
    return(9)
  }else if("$10+ billion (USD)"){ 
    return(12)
  }else if("$500 million to $1 billion (USD)"){ 
    return(8)
  }else if("$10 to $25 million (USD)"){ 
    return(4)
  }else if("$50 to $100 million (USD)"){ 
    return(6)
  }else if("$5 to $10 million (USD)"){ 
    return(3)
  }
  
}
```


```{r}
clean_data <- clean_data %>% 
  mutate(
    `Revenue Ordered`=
           case_when(
             Revenue=="Less than $1 million (USD)"       ~ 1,
             Revenue=="$1 to $5 million (USD)"           ~ 2,
             Revenue=="$5 to $10 million (USD)"          ~ 3,
             Revenue=="$10 to $25 million (USD)"         ~ 4,
             Revenue=="$25 to $50 million (USD)"         ~ 5,
             Revenue=="$50 to $100 million (USD)"        ~ 6,
             Revenue=="$100 to $500 million (USD)"       ~ 7,
             Revenue=="$500 million to $1 billion (USD)" ~ 8,
             Revenue=="$1 to $2 billion (USD)"           ~ 9,
             Revenue=="$2 to $5 billion (USD)"           ~ 10,
             Revenue=="$5 to $10 billion (USD)"          ~ 11,
             Revenue=="$10+ billion (USD)"               ~ 12 
         ),
    Revenue=
           case_when(
             Revenue=="Less than $1 million (USD)"       ~ "0-1000000",
             Revenue=="$1 to $5 million (USD)"           ~ "1000000-5000000",
             Revenue=="$5 to $10 million (USD)"          ~ "5000000-10000000",
             Revenue=="$10 to $25 million (USD)"         ~ "10000000-25000000",
             Revenue=="$25 to $50 million (USD)"         ~ "25000000-50000000",
             Revenue=="$50 to $100 million (USD)"        ~ "50000000-100000000", 
             Revenue=="$100 to $500 million (USD)"       ~ "100000000-500000000",
             Revenue=="$500 million to $1 billion (USD)" ~ "500000000-1000000000",
             Revenue=="$1 to $2 billion (USD)"           ~ "1000000000-2000000000",
             Revenue=="$2 to $5 billion (USD)"           ~ "2000000000-5000000000",
             Revenue=="$5 to $10 billion (USD)"          ~ "5000000000-10000000000",
             Revenue=="$10+ billion (USD)"               ~ "10000000000-Inf",
         )
         
) %>% 
  separate(Revenue, sep="-", into=c("Revenue Inf","Revenue Sup")) %>% 
  mutate(
    `Revenue Inf`=as.numeric(`Revenue Inf`),
    `Revenue Sup`=as.numeric(`Revenue Sup`)
  )
  
```


Más columnas a tener en cuenta para NAs

-Salary Med 
-Size

Subselección de las variabels de interés (No): 
-Rating 
-index
-competitors
-founded

Pasos previos: 

- Estudiar Normalidad Salary --> Robert 
- Outlier --> Geovanny

## Tratamiento de *outliers* de la variable `Salary Estimate Med`

```{r}
boxplot(clean_data$`Salary Estimate Med`, main="")
salary_outliers <- unique(boxplot.stats(clean_data$`Salary Estimate Med`)$out)
salary_outliers
```

Observamos que, por lo general, la variable `Salary Estimate Med` tiene una distribución de valores bastante consistente, lo cual podemos comprobar dado el pequeño tamaño de su rango intercuartílico (caja). No obstante, vemos como existen puntos fuera de este rango y de los *whiskers*, los conocidos como *outliers*. En concreto, son dos puntos: 43.5 y 271.5. A continuación, estudiaremos a que registros corresponden a estos valores.  

```{r}
clean_data %>% 
  filter(
    `Salary Estimate Med` == 43.5
  ) %>% View
```

En este caso, observamos como este salario atípicamente bajo corresponde con posiciones en las que no se piden experiencia (lo podemos comprobar por la variable `Job Description`) y además, se encuentran en ciudades de Estados Unidos poco punteras (tecnologicamente hablando), como por ejemplo "Lincoln", "Arlington", "Saint Paul", etc.. Por tanto, podemos concluir que estas variables no se tratan de errores en el dataset, sino de valores totalmente legítimos que debemos tener en cuenta para las pruebas estadísticas posteriores. 

```{r}
clean_data %>% 
  filter(
    `Salary Estimate Med` == 271.5
  ) %>% View
```

En este caso podemos observar lo contrario, un valor que se diferencia del resto por ser demasiado alto. Al igual que antes, hemos analizado cada uno de estos registros con el objetivo de observar que es lo que les diferencia del resto. En una primera instancia pensabamos que se tratarían de posiciones para managers y seniors, pero la realidad es que hemos encontrado diferentes motivos por los cuales se pueden dar estos valores:

  * Posiciones para managers, seniors o PhDs.
  * Ciudad muy punteras en el ambito tecnológico. Ex. "Seattle", "New York", "Washington", etc.
  * Empresas muy top. Ex. "Roche", "Aztrazeneca", "Maxar Technologies", etc.

Dado que estos salarios tan altos son totalmente justificables (por las razones planteadas, entre otras), mantendremos entre registros para las pruebas estadísticas posteriores. 


Preguntas: 

1- Relación ente el trabajo y el salario . chisquared --> Robert 
2- Relación entre sede `Same Location Headquarter` y `Salary Estimate Med` --> Geovanny 

Nos gustaría conocer si existe alguna relación entre el salario estimado medio y el lugar de la sede frente a la localización del trabajo (la variable `Same Location Headquarter` es `TRUE` si la localización de la sede es igual a la de la posición que se ofrece). Para ello, realizaremos una regresión logística:

```{r}
summary(glm(`Same Location Headquarter`~`Salary Estimate Med`,family=binomial(link=logit), data=clean_data))
```

Observamos que la relación lineal que obtenemos entre estas dos variables es indirectamente proporcional, en concreto, de -0.0028. Una correlación muy baja, pero es que además, es una correlación no significativa (*p-value* de 0.217, para un intervalo de confianza del 95%), por tanto, podemos afirmar que la variable `Same Location Headquarter` no nos aporta practicamente suficiente información y podríamos prescindir de ella. 

3- Comparación entre type of ownerships y salarios --> Robert  
4- Relación entre industry y salario --> Geovanny

Antes de calcular la posible relación entre estas dos variables, sería interesante poder ver de forma gráfica las diferencias entre los salarios para cada una de las industrias disponibles en el dataset. Dado que existen más de 50 valores diferentes para la variable de `Industry`, procederemos a representar al menos las 7 primeras industrias con más concurrencia en el dataset. 

```{r}
#sort(table(clean_data$Industry),descending=T)
length(unique(clean_data$Industry))
clean_data %>%
  filter(!is.na(Industry)) %>%
  count(Industry, sort=T) %>%
  head(7)

clean_data %>%
  filter(!is.na(Industry)) %>%
  add_count(Industry) %>%
  arrange(desc(n)) %>% # igual a add_count(Industry,sort=T)
  slice_max(n, prop=0.5) %>%
  ggplot(aes(x=Industry, y=`Salary Estimate Med`)) + geom_bar(stat="summary", fun="mean", fill="steelblue")+coord_flip()
```

A simple vista no observamos diferencias considerables entre los salarios medios para cada una de las industrias mostradas en el gráfico. Vemos como casi todas ofrecen salarios cercanos a los 125.000\$. La industria aeroespacial es la que mejor pagada, superando los 150.000\$ anuales.


```{r}
summary(lm(`Salary Estimate Med`~Industry, data=clean_data))
```

5- Revenue y salary --> Geovanny

6- Size (máx) y salary --> Robert 
